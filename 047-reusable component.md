## 0. 공부하게 된 계기

동아리 면접 때 거짓말치다가 걸렸다...

현재 첫 회사에 입사해 본격적으로 일한지 2개월이 되지 않았다.  
지금까지 맡은 업무는 사장된 Angular.js를 React.js로 전환하는 일이 전부이다.  
그래서 설계 등에 대해 고민할 것이 적었다.  
공통적으로 사용되는 메서드는 HoC로 분리하든가 util 함수를 선언하든가, 하나의 메서드가 너무 크면 분리하든가, 변수명이 명확하지 않으면 변경하거나, 레거시 코드 제거하는 일 정도는 했다.  
하지만 좋은 컴포넌트는 무엇인가에 대한 고민은 많이 하지 않았다.  
(현재 테스트 코드가 없기 때문에...)컴포넌트를 분리하거나 구조를 변경하는 순간 영향도가 급격히 증가하기 때문에 랜딩 프로젝트로 진행하는 현재로서는 해당 부분을 생각하기까지에 부담스러운 부분이 있었다.

그런데 이 부분에 대해 고민했다고 말해서 이러쿵 저러쿵 하다가... "재사용 가능한 컴포넌트가 무엇일까"라는 말에 말문이 막혔다.  
FE 개발자로서... 이런 부분에 대해 대답을 못 한다면 공부해야겠지??

참고  
http://www.ktword.co.kr/test/view/view.php?m_temp1=2837  
http://wiki.hash.kr/index.php/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8

## 1. 컴포넌트란

React의 장점 중 하나로 꼽히는 것이 컴포넌트 기반으로 개발한다는 것이다.  
여기서 말하는 *컴포넌트*의 정의부터 되짚어보자.  
[해시넷](http://wiki.hash.kr/index.php/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8)에 따르면

> 컴포넌트(component)란 여러 개의 프로그램 함수들을 모아 하나의 특정한 기능을 수행할 수 있도록 구성한 작은 기능적 단위를 말한다. 컴포넌트를 이용하면 소프트웨어 개발을 마치 레고(Lego) 블록을 쌓듯이 조립식으로 쉽게 할 수 있다. 모듈(module)이라고도 한다. 컴포넌트는 프로그램의 한 부분을 의미하며 재사용이 가능한 최소 단위를 말한다.

여기서 집중해야 할 것은 **재사용 가능한 최소 단위**라는 것이다.  
이 정의에 입각해 규칙을 세우고 개발을 진행해야 CBD(Component Based Development, 재사용 가능한 컴포넌트의 개발 또는 상용 컴포넌트를 조합하여 하나의 새로운 응용 프로그램을 만드는 소프트웨어 개발 방법론)에 맞는 개발을 진행할 수 있다.

## 2. 좋은 컴포넌트란

좋은 컴포넌트, 즉 잘 짠 컴포넌트는 **재사용 가능한** 컴포넌트라는 결론을 얻었다(사실 정의에 입각했을 뿐이다).  
재사용 가능한 컴포넌트는 **어떤 맥락(사용하고 있는 페이지나 컴포넌트)에서 사용되든 동일한 역할을 하고 일관된 UI를 렌더링한다.**  
재사용 가능한 컴포넌트는 외부와 인터페이스(React에서는 `props`로 볼 수 있다)를 통해 소통한다.  
이 인터페이스는 해당 컴포넌트를 사용하는 쪽을 위한 것이며, 컴포넌트를 사용하는 쪽에서는 인터페이스를 보고 어떻게 동작할지 예상하다.  
어떠한 곳에서 사용되든, 동일한 형태의 버튼을 렌더링 한다든가(버튼 margin, 위치 등은 외부에서 결정한다), 목록을 렌더링 한다든가(목록에 넣어줄 데이터는 외부에서 주입한다)... 토글 / API 요청 등등 본인이 해야 하는 역할을 컴포넌트의 인터페이스 변경 없이 사용 가능하다.

여러 글들을 읽어본 결과, 재사용성이 높은 컴포넌트는 "추상화"를 통해 역할과 책임에 따라 분리된다.  
역할과 책임에 따른 컴포넌트 분리는 두 가지 추가적인 이점을 가져다준다.
첫 번째는 컴포넌트를 테스트하기 쉽게 만든다.  
(TODO: 책임이 적어지기 때문에. 테스트할 범위가 좁아지고, 테스트 코드가 통과하기 위한 억지 모킹이 줄어들 수 있을 것이라 기대한다. 이 내용은 사이드 프로젝트를 끝내고 다시 후기를 작성하러 와보자)
두 번째는 컴포넌트를 변경에 유연하도록 만든다.  
어느 곳에서든 쓸 수 있도록 비즈니스 로직이 분리되고, 일반적인 인터페이스로 디자인되기 때문이다.

### 여기서 한 가지 짚고 넘어가자면

프로젝트에서 무조건 재사용성 높은 컴포넌트 선언이 1순위가 아니다.  
얻는 게 있으면 잃는 게 있다는 것 반드시 기억하자.
'인터페이스 변경 없이 사용 가능하게 하기' 또는 '추가적인 컴포넌트 선언을 없애기'를 1순위로 하면 컴포넌트 그리고 컴포넌트의 인터페이스가 너무 비대해질 수 있다.

다음과 같이 부트스트랩 모양의 버튼, 닫기 모양의 버튼 이렇게 두 가지 종류의 버튼이 있다고 하자.

![bootstrap buttons](https://user-images.githubusercontent.com/63287638/234282991-3a48bc2b-8620-4f2d-aa6d-05a45d4d2e8c.png)

![X button](https://user-images.githubusercontent.com/63287638/234282726-725c426e-9d55-4ad2-b8b6-fddea3b1abb1.png)

'컴포넌트를 2개로 따로 선언하는 것이 재사용성을 해치니까 나는 1개로 선언해야지! 이 프로젝트에 버튼 컴포넌트는 무조건 하나야'라는 생각으로 다음과 같이 선언할 수 있다.

```js
function Button({ onClick, className = '', children, isClose }) {
  return isClose ? (
    <button
      onClick={onClick}
      className={`button-base ${className}`}
      style={{ margin: 3 }}
    >
      X
    </button>
  ) : (
    <button
      onClick={onClick}
      className={`button-base ${className}`}
      style={{ margin: 4 }}
    >
      {children}
    </button>
  );
}
```

취향 차이일 수 있다.  
나는! 개인적으로! 역할, UI가 명확히 구분되고 다르다면 아래와 같이 두 가지 컴포넌트로 분리하는 것이 낫다고 생각한다...  
`isClose`나 인터페이스나 삼항 연산자 문법이 필요 없기 때문이다.

```js
function BootstrapButton({ onClick, className = '', children }) {
  return (
    <button
      onClick={onClick}
      className={`button-base ${className}`}
      style={{ margin: 4 }}
    >
      {children}
    </button>
  );
}
```

```js
function CloseButton({ onClick, className = '' }) {
  return (
    <button
      onClick={onClick}
      className={`button-base ${className}`}
      style={{ margin: 3 }}
    >
      X
    </button>
  );
}
```

## 3. 재사용 가능한 컴포넌트 만드는 방법

그렇다면 재사용 가능한 컴포넌트는 어떻게 만드는가?

### 1) 추상화 / 일반적인 인터페이스로 디자인한다. (+ 그 이전에 [비즈니스 로직이 없거나 상태값이 없도록 분리한다](https://as-you-say.tistory.com/221))

### 2) 디자인 시스템을 이용한다.

### 3) 디자인 패턴을 사용한다.

---

컴포넌트 다시 생각하기 요약  
컴포넌트: props + hooks에게 의존성을 주입 받음.  
그런한 것 중.

1. 스타일(코드 안)
2. UI 조작에 필요한 커스텀 로직 or 사이드 이펙트(코드 안)
3. store / theme 등 전역 상태(코드 안)
4. remote data schema(API 서버에서 내려주는 데이터의 모양)(코드 밖)

만약 Article 컴포넌트에 새로운 정보가 추가된다면 => remote data에 의해 컴포넌트의 props를 수정 => 렌더링 부분 수정 => ArticleList의 props 수정 => PageArticleList의 useEffect 훅 수정(props drilling을 사용하지 않더라도 페이지 기반 라우팅을 한다면 결국 root component에 의존함)

의존성 정리 방법

1. 비슷한 관심사라면 가까운 곳에(co-locate). (CSS in JS / custom hook / store에서 식별자 값을 통해 해당 데이터만 custom hook <- 2번 내용)
2. 데이터를 ID 기반으로 정리(데이터 정규화)
3. 의존한다면 그대로 드러내기(props 이름을 일반화시키는 것과 반대)
4. UI가 비슷한지에 상관 없이 모델 기준으로 컴포넌트 분리하기
