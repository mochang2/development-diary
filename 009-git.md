## 0. 공부하게 된 계기
나 혼자 쓰는 프로젝트에서만 깃을 쓰다가 같이 쓰는 프로젝트에 commit을 하다 보니 규칙을 잘 이해해야 한다고 생각이 들었고,  
규칙을 잘 이해하기 위해서는 헷갈리는 개념을 다시 정리해야 될 필요가 있다고 느꼈다.  
깃이 꼬이는 것을 방지하기 위해 기초 개념부터 다시 정리하기로 했다.  

## 깃의 세 가지 트리
깃은 일반적으로 HEAD, Index, 워킹 디렉토리, 이 세 가지 트리를 관리하는 시스템이다.  

##### 1) HEAD
마지막 commit 스냅샷이자 다음 commit의 부모 commit 역할을 한다.  
현재 branch를 가리키는 포인터이며, branch에 담긴 commit 중 가장 마지막 commit을 가리킨다.

##### 2) Index
엄밀히 말하면 트리구조는 아니고 평평한 구조로 구현되었지만 설명을 쉽게 하기 위해 트리구조라고 말한다고 한다.  
Index는 다음에 commit할 스냅샷이다.  
[아래](https://github.com/mochang2/development-diary/edit/main/009-git.md#1-git-stage)에 나올 staging area와 관련이 있다.  
Index는 워킹 디렉토리에서 마지막으로 checkout 한 branch의 파일 목록과 파일 내용으로 채워진다.  
이후 파일 변경작업을 하고 변경한 내용으로 Index를 업데이트 할 수 있다.  
이렇게 업데이트하고 `git commit` 명령을 실행하면 Index는 새 commit으로 변환된다.  

##### 3) working directory
샌드박스 역할을 한다.  
위의 두 트리는 파일과 그 내용을 효율적인 형태로 `git` 디렉토리에 저장하지만 사람이 알아보기 어렵다.  
하지만 워킹 디렉토리는 실제 파일로 존재해서 사용자가 편집하기 수월하게 도와준다.  

## 1. git stage
깃 상태는 크기 tracked, untracked 상태로 나뉘고, tracked 상태는 다시 modified, unmodified, staged 상태로 나뉜다.  
untracked 상태는 git에서 형상 관리를 하지 않는 상태이다.  
track을 하고 싶으면 add를 하면 된다.  
modified 상태는 tracked 된 상태에서 파일이 변경되었다는 의미이다.  
즉, 형상관리에 들어간 파일이 commit 이후에 새로운 변화가 생기면 modified 상태가 된다.  
반대로 unmodified 상태는 commit 이후에 새로운 변화가 없는 상태를 말한다.  
stage 상태는 commit 전 상태라고 생각하면 와닿을 것이다.  
형상관리에 들어가지 않았던 파일이나 들어갔지만 modified 상태의 파일을 대상으로 git add하면 되는 상태이다.

```
file -> (git add) -> staged -> (git commit) -> unmodified
```

위와 같은 그림이 내가 가장 이해할 수 있는 그림인 것 같다.


## 2. git stash
##### 임시 저장(tmp 디렉토리와 비슷). stack과 같은 구조를 가짐
https://www.lainyzine.com/ko/article/git-stash-usage-saving-changes-without-commit/ 이 주소에 더 자세히 나와있다.  
이전에는 수정된 코드를 아직 commit하지 않은 상태일 때, 임시 저장을 하지 않는다면 변경사항 전체를 하드 리셋하거나,  
저장소를 하나 더 클론 받아오거나 급하게 변경된 부분까지만 commit하는 방법을 써야 됐다고 한다.  
이러한 문제를 해결하기 위해 나온 것이 git stash이다.  
commit은 하지 않지만 변경된 부분을 저장하기 위해 존재한다.  

##### 간단한 사용법
git stash는 임시 저장을 하는 명령어로 git stash save의 약어이다.  
git stash -m 'message'로 저장할 수도 있고 stash를 보기 위해서는 git stash list를 하면 된다.  
git stash pop은 임시 저장된 내용을 꺼내오면서 삭제하는 명령어이다.  
git apply(꺼내옴) git drop(stash에서 삭제) 두 명령어가 합쳐진 것이라 생각하면 된다.  

##### 결국 merge와 비슷하다
임시 저장한 뒤에 다시 같은 파일에(같은 줄에) 어떤 작업을 하고, git stash pop을 하면 어떻게 될까?  
conflict가 난다.  
이를 해결하기 위해서 conflict를 하나하나 해결하는 merge와 비슷한 일을 해야 된다.  

##### 사용하는 이유
불필요한 commit을 남기지 않는 이유가 가장 큰 것 같다.  
이와 비슷한 방식으로 임시적으로 commit을 남긴 뒤, 다음 commit에서 `git commit --amend` 명령어를 사용함으로써 이전 commit 내용을 수정할 수 있다.

## 3. git merge vs git rebase
동작은 같지만 commit tree 관리에 차이가 생긴다.  
merge는 분기된 branch가 합쳐지는 graph가 나타난다.  
반면 rebase는 해당 위치를 기준으로 분기 위치를 다시 잡게 된다.  
rebase를 하면 commit도 새로 쓰고(commit 해시도 달라짐) commit 히스토리 정렬도 새로되기 때문에 기존의 commit트리가 달라진다.  
자세한 차이는 https://brunch.co.kr/@anonymdevoo/7,  
https://dongminyoon.tistory.com/9  여기에 그림과 같이 잘 정리되어 있다.  

```
// branch의 base를 master로 변경
git checkout branch
git rebase master

// conflict가 나면 해결한 뒤에 rebase 진행
git rebase --continue

// rebase를 하기 이전으로 돌리려면
git rebase --abort
```

## 4. git resolve
만약 서로 다른 branch가 같은 파일, 같은 줄을 동시에 바꾸게 되어 merge 등의 행위를 못 하는 경우 'conflict'가 났다고 표현한다.  
그 conflict를 해결하는 것을 resolve한다고 한다.  
conflict를 해결하기 위해서는 하나를 제외하고 나머지 branch들의 내용을 포기해야 할 수도 있고, 모든 변경 사항을 받아들일 수도 있다.  
이러한 과정을 강제로 병합시키지 않는 이상 손수 하나하나 찾아가며 바꾸는 것이 일반적으로 맞다.  
resolve를 하기 위한 방법 중 commit을 되돌림으로써 해결하는 방법에는 3가지 정도가 있다.  

##### 1) reset으로 commit 돌리기
https://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-Reset-%EB%AA%85%ED%99%95%ED%9E%88-%EC%95%8C%EA%B3%A0-%EA%B0%80%EA%B8%B0 에서 reset의 근본적인 원리를 설명해준다.  
기본적으로 reset은 branch를 이동시키는 checkout과 달리, HEAD가 가리키는 commit을 옮긴다.  
`git reset --soft` 옵션을 주면 HEAD를 이전 commit으로 돌린다. 즉, `git add`는 되어 있다.  
`git reset --mixed` 옵션을 주면 Index를 업데이트 이전으로 돌린다. 즉, `git add` 이전 상태가 된다.  
`git reset --hard` 옵션은 working directory를 이전으로 돌린다. 변경된 내용이 로컬에서도 삭제되는 것이므로 조심히 써야 되는 옵션이다.  

##### 2) revert로 commit 돌리기
reset이 HEAD의 위치를 돌려주는 명령어였다면, revert는 commit의 내용을 되돌리는 commit을 만드는 명령어이므로 좀더 안전하다고 볼 수 있다.  
사용하는데 약간 불편한 점이 있다면, 가장 최근의 commit부터 revert하지 않으면 conflict가 날 수 있다는 것이다.  

```
// 바로 직전의 commit을 되돌림
git revert HEAD

// 특정 commit의 내용을 되돌림. 이때 conflict가 날 수도 있음
git revert [COMMIT_ID]

// 여러 commit을 한꺼번에 되돌림
git revert [COMMIT_ID1] [COMMIT_ID2] ...

// 여러 commit을 단일 commit으로 revert
git revert -n [COMMIT_ID1] [COMMIT_ID2] ...

// revert commit 메시지 편집하지 않기
--no-edit

// merge commit으로 되돌리기. 어느 commit으로 되돌릴지 알아야 되기 때문에 옵션을 사용하지 않으면 에러 반환
git rever -m <git show에서 보여지는 Merge: 뒤의 값들에 차례대로 부여된 번호 이용> [COMMIT_ID]
```

##### 3) branch를 만들어서 commit 돌리기
이 방법은 쉽지만 트리가 지저분해질 수 있다는 단점이 있다.  
방법은 다음과 같다.  
되돌릴 commit을 대상으로 branch를 생성한다.  
생성된 branch로 checkout한 뒤 되돌릴 부분에 대해서 작업을 진행한다.  
변경된 내용을 토대로 기준 branch에 merge한다.

## 5. cherry picker
케이크 위의 체리만 쏙 빼먹는, 얌체 같은 사람을 체리피커라고 한다.  
이와 비슷한 의미로 사용되는 깃 명령어이다.  
https://cselabnotes.com/kr/2021/03/31/56/ 여기를 참고했다.  
commit을 다른 branch에 잘못 하거나, 요구 사항이 바뀌어 필요 없는 commit이 생기거나, 코드 의존성 때문에 다른 사람의 commit 중 일부를 가져와야 하는 경우에 rebase나 cherry-pick의 방법을 사용할 수 있다.  
cherry-pick이 그렇게 권장되는 명령어는 아니지만 rebase의 번거로움(다른 branch에서 commit을 가져오고 싶다면 먼저 그 branch를 현재 branch로 merge한 후 rebase)를 감수하기 싫다면 사용하기 좋은 방법이라고 한다.  

##### 개념
git cherry-pick <commit hash>을 하면 해당 commit의 내용을 현재 작업중인 branch로 가져온다.  
git cherry-pick <commit hash1>...<commit hash2>을 하면 해당 commit들 사이에 있는 모든 commit들을 가져온다.  
cherry-pick을 사용해도 당연히 conflict가 일어날 수 있다.  
conflict를 해결한 뒤에 git cherry-pick -continue를 사용하면 다시 cherry pick이 진행된다.  
git cherry-pick -abort를 사용하면 cherry pick을 하기 전 상태로 돌아간다.  
